{"notebook_name":"AdvectionTests.ipynb"}
{"metadata":{},"cell_type":"markdown","source":"# Advection tests\n\nThis notebook presents an implementation of the first-order upwind method on the scalar \nadvection equation  $q_t + \\bar u q_x = 0$ with periodic boundary conditions.\n\nTo load numpy and matplotlib and force plots to appear inline:"}
{"metadata":{},"cell_type":"code","input":"%pylab inline  ","prompt_number":null,"outputs":[],"language":"python","trusted":false,"collapsed":false}
{"metadata":{},"cell_type":"markdown","source":"## Some Python tips\n\nSee also <http://faculty.washington.edu/rjl/classes/am574w2015/python.html>\n\n- The extent of for loops, if-then-else blocks, function definitions is determined entirely by indentation.\n- Array indexes start a 0, so a list or array A with 3 elements would be indexed by `A[0], A[1], A[2]`.\n- `range(3)` gives the list [0,1,2].\n- `range(1,4`) gives the list [1,2,3].\n- If A has at least 4 elements then `A[1:4]` is a new list `[A[1], A[2], A[3]]`\n- The linspace command works as in Matlab, and returns a numpy array (not a list)\n"}
{"metadata":{},"cell_type":"markdown","source":"## Define a function implementing the upwind method\nThis function approximates the solution from time $t_0 = 0$ to some final time `tfinal` by taking `nsteps` time steps with the upwind method, applied to the advection equation $q_t + \\bar u q_x = 0$.\n\nOn input, `x` is an array of cell centers and `q0` should be an array of the same length, containing the initial cell averages at time 0."}
{"metadata":{},"cell_type":"code","input":"def upwind(ubar,q0,x,tfinal,nsteps):\n    dt = float(tfinal)/nsteps\n    dx = x[1] - x[0]  # assume equally spaced\n    udtdx = ubar * dt / dx\n    cfl = abs(udtdx)\n    print \"dx = %g,  dt = %g\" % (dx,dt)\n    print \"Courant number is \",cfl\n    \n    qn = hstack([0, q0, 0])   # add a ghost cell on each end\n    mx = len(x)  # number of grid cells\n    mx2 = mx+2   # number of cells with ghost cells\n    for n in range(nsteps):\n        qn[0] = qn[mx]\n        qn[mx+1] = qn[1]\n        qnp = zeros(qn.shape)   # initialize array\n        for i in range(1,mx+1):\n            if ubar > 0:\n                qnp[i] = qn[i] - udtdx * (qn[i]-qn[i-1])\n            else:\n                qnp[i] = qn[i] - udtdx * (qn[i+1]-qn[i])\n                \n        qn = qnp   # for next time step\n    qfinal = qnp[1:(mx+1)]   # throw away ghost cells\n    return qfinal","outputs":[],"language":"python","trusted":false,"collapsed":false}
{"metadata":{},"cell_type":"markdown","source":"Set up the computational grid and also a much finer grid for plotting the \"exact\" solution:"}
{"metadata":{},"cell_type":"code","input":"mx = 50\ndx = 1./mx\nx = linspace(dx/2, 1.-dx/2, mx)  # computational grid\nxfine = linspace(0,1,5000)   # fine grid for plotting true solution","outputs":[],"language":"python","trusted":false,"collapsed":false}
{"metadata":{},"cell_type":"markdown","source":"Define the true solution as a function of $(x,t)$.  It will depend on `ubar`.  \n\nNote how the periodic boundary conditions are imposed."}
{"metadata":{},"cell_type":"code","input":"def qtrue(x,t,ubar):\n    x0 = x - ubar*t   # trace back characteristic to time 0\n    x0 = mod(x0, 1.)  # use periodic boundary conditions to map to [0,1]\n    q = where(abs(x0-0.2) < 0.1,  3., 2.)   # piecewise constant with values 2 and 3\n    return q\n","outputs":[],"language":"python","trusted":false,"collapsed":false}
{"metadata":{},"cell_type":"markdown","source":"Plot the initial data, with blue dots for the cell averages on the computational grid and a red line for the \"exact\" data."}
{"metadata":{},"cell_type":"code","input":"ubar = 1.\nq0 = qtrue(x,0.,ubar)\nplot(x,q0, 'bo')\n\nq0fine = qtrue(xfine,0.,ubar)\nplot(xfine,q0fine,'r-')\nylim(1,4)","outputs":[],"language":"python","trusted":false,"collapsed":false}
{"metadata":{},"cell_type":"markdown","source":"Test the upwind method for specific values of the parameters:"}
{"metadata":{},"cell_type":"code","input":"tfinal = 0.5\nnsteps = 30\nq0 = qtrue(x,0.,ubar)\nq = upwind(ubar,q0,x,tfinal,nsteps)\nqfine = qtrue(xfine,tfinal,ubar)  # \"exact\" solution\nplot(x,q, 'bo')\nplot(xfine,qfine,'r-')\nylim(1,4)","outputs":[],"language":"python","trusted":false,"collapsed":false}
{"metadata":{},"cell_type":"markdown","source":"## Try the following:\n\n- Check that this code works if `ubar` is negative and/or if the time interval is longer, so that the periodic boundary conditions play a role.\n- With `tfinal = 0.5`, try the following and make some observations about the results in each case:\n  - `nsteps = 25` (why is the result so good?)\n  - `nsteps = 24` (why is the result so bad?)\n- Write a new function `lax_friedrichs` that implements the Lax-Friedrichs method.  Try various paramter values and comment on the results.\n- Try both upwind and Lax-Friedrichs on the initial data $q_0(x) = \\exp(-30(x-0.2)^2)$ for $0 \\leq x \\leq 1$ and comment on what you observe.\n- Implement the second-order accurate Lax-Wendroff method and try it out on these examples.\n\n$$Q_i^{n+1} = Q_i^n - \\frac{\\bar u \\Delta t}{2\\Delta x}(Q_{i+1}-Q_{i-1}) + \\frac 1 2 \\left(\\frac{\\bar u \\Delta t}{\\Delta x}\\right)^2 (Q_{i+1} - 2Q_i + Q_{i-1})$$"}
{"metadata":{},"cell_type":"code","input":"","outputs":[],"language":"python","trusted":false,"collapsed":false}