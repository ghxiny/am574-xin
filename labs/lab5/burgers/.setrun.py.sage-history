"\"\"\"\nModule to set up run time parameters for Clawpack -- classic code.\n\nThe values set in the function setrun are then written out to data files\nthat will be read in by the Fortran code.\n    \n\"\"\" \n\nimport os\nimport numpy as np\n\n#------------------------------\ndef setrun(claw_pkg='classic'):\n#------------------------------\n    \n    \"\"\" \n    Define the parameters used for running Clawpack.\n\n    INPUT:\n        claw_pkg expected to be \"classic\" for this setrun.\n\n    OUTPUT:\n        rundata - object of class ClawRunData \n    \n    \"\"\" \n    \n    from clawpack.clawutil import data \n    \n    \n    assert claw_pkg.lower() == 'classic',  \"Expected claw_pkg = 'classic'\"\n\n    num_dim = 1\n    rundata = data.ClawRunData(claw_pkg, num_dim)\n\n    #------------------------------------------------------------------\n    # Problem-specific parameters to be written to setprob.data:\n    #------------------------------------------------------------------\n    \n    probdata = rundata.new_UserData(name='probdata',fname='setprob.data')\n    probdata.add_param('beta',  200., 'for width of Gaussian data')\n    \n    #------------------------------------------------------------------\n    # Standard Clawpack parameters to be written to claw.data:\n    #------------------------------------------------------------------\n\n    clawdata = rundata.clawdata  # initialized when rundata instantiated\n\n\n    # ---------------\n    # Spatial domain:\n    # ---------------\n\n    # Number of space dimensions:\n    clawdata.num_dim = num_dim\n    \n    # Lower and upper edge of computational domain:\n    clawdata.lower[0] = 0.000000e+00          # xlower\n    clawdata.upper[0] = 2.000000e+00          # xupper\n    \n    # Number of grid cells:\n    clawdata.num_cells[0] = 200      # mx\n    \n\n    # ---------------\n    # Size of system:\n    # ---------------\n\n    # Number of equations in the system:\n    clawdata.num_eqn = 1\n\n    # Number of auxiliary variables in the aux array (initialized in setaux)\n    clawdata.num_aux = 0\n    \n    # Index of aux array corresponding to capacity function, if there is one:\n    clawdata.capa_index = 0\n    \n    \n    # -------------\n    # Initial time:\n    # -------------\n\n    clawdata.t0 = 0.000000\n    \n\n    # Restart from checkpoint file of a previous run?\n    # Note: If restarting, you must also change the Makefile to set:\n    #    RESTART = True\n    # If restarting, t0 above should be from original run, and the\n    # restart_file 'fort.qNNNN' specified below should be in \n    # the OUTDIR indicated in Makefile.\n\n    clawdata.restart = False               # True to restart from prior results\n    clawdata.restart_file = 'fort.q0006'   # File to use for restart data\n    \n    \n    # -------------\n    # Output times:\n    #--------------\n\n    # Specify at what times the results should be written to fort.q files.\n    # Note that the time integration stops after the final output time.\n \n    clawdata.output_style = 1\n \n    if clawdata.output_style==1:\n        # Output ntimes frames at equally spaced times up to tfinal:\n        # Can specify num_output_times = 0 for no output\n        clawdata.num_output_times = 20\n        clawdata.tfinal = 3.000000\n        clawdata.output_t0 = True  # output at initial (or restart) time?\n        \n    elif clawdata.output_style == 2:\n        # Specify a list or numpy array of output times:\n        # Include t0 if you want output at the initial time.\n        clawdata.output_times =  [0., 0.1]\n \n    elif clawdata.output_style == 3:\n        # Output every step_interval timesteps over total_steps timesteps:\n        clawdata.output_step_interval = 2\n        clawdata.total_steps = 4\n        clawdata.output_t0 = True  # output at initial (or restart) time?\n        \n\n    clawdata.output_format = 'ascii'      # 'ascii', 'binary', 'netcdf'\n\n    clawdata.output_q_components = 'all'   # could be list such as [True,True]\n    clawdata.output_aux_components = 'none'  # could be list\n    clawdata.output_aux_onlyonce = True    # output aux arrays only at t0\n    \n\n    # ---------------------------------------------------\n    # Verbosity of messages to screen during integration:  \n    # ---------------------------------------------------\n\n    # The current t, dt, and cfl will be printed every time step\n    # at AMR levels <= verbosity.  Set verbosity = 0 for no printing.\n    #   (E.g. verbosity == 2 means print only on levels 1 and 2.)\n    clawdata.verbosity = 0\n    \n    \n\n    # --------------\n    # Time stepping:\n    # --------------\n\n    # if dt_variable==True:  variable time steps used based on cfl_desired,\n    # if dt_variable==False: fixed time steps dt = dt_initial always used.\n    clawdata.dt_variable = True\n    \n    # Initial time step for variable dt.  \n    # (If dt_variable==0 then dt=dt_initial for all steps)\n    clawdata.dt_initial = 1.000000e-01\n    \n    # Max time step to be allowed if variable dt used:\n    clawdata.dt_max = 1.000000e+99\n    \n    # Desired Courant number if variable dt used \n    clawdata.cfl_desired = 0.800000\n    # max Courant number to allow without retaking step with a smaller dt:\n    clawdata.cfl_max = 1.000000\n    \n    # Maximum number of time steps to allow between output times:\n    clawdata.steps_max = 5000\n\n\n    # ------------------\n    # Method to be used:\n    # ------------------\n\n    # Order of accuracy:  1 => Godunov,  2 => Lax-Wendroff plus limiters\n    clawdata.order = 2\n    \n    \n    # Number of waves in the Riemann solution:\n    clawdata.num_waves = 1\n    \n    # List of limiters to use for each wave family:  \n    # Required:  len(limiter) == num_waves\n    # Some options:\n    #   0 or 'none'     ==> no limiter (Lax-Wendroff)\n    #   1 or 'minmod'   ==> minmod\n    #   2 or 'superbee' ==> superbee\n    #   3 or 'vanleer'  ==> van Leer\n    #   4 or 'mc'       ==> MC limiter\n    clawdata.limiter = [0] #['minmod']\n    \n    clawdata.use_fwaves = False    # True ==> use f-wave version of algorithms\n    \n    # Source terms splitting:\n    #   src_split == 0 or 'none'    ==> no source term (src routine never called)\n    #   src_split == 1 or 'godunov' ==> Godunov (1st order) splitting used, \n    #   src_split == 2 or 'strang'  ==> Strang (2nd order) splitting used,  not recommended.\n    clawdata.source_split = 0\n    \n    \n    # --------------------\n    # Boundary conditions:\n    # --------------------\n\n    # Number of ghost cells (usually 2)\n    clawdata.num_ghost = 2\n    \n    # Choice of BCs at xlower and xupper:\n    #   0 or 'user'     => user specified (must modify bcNamr.f to use this option)\n    #   1 or 'extrap'   => extrapolation (non-reflecting outflow)\n    #   2 or 'periodic' => periodic (must specify this at both boundaries)\n    #   3 or 'wall'     => solid wall for systems where q(2) is normal velocity\n    \n    clawdata.bc_lower[0] = 'periodic'   # at xlower\n    clawdata.bc_upper[0] = 'periodic'   # at xupper\n                  \n    return rundata\n\n    # end of function setrun\n    # ----------------------\n\n\nif __name__ == '__main__':\n    # Set up run-time parameters and write all data files.\n    import sys\n    rundata = setrun(*sys.argv[1:])\n    rundata.write()\n    \n"
{"patch":[[[[0,"ter = [0"],[1," "],[0,"] #['min"]],5814,5814,16,17]],"time":1423268744092}
{"patch":[[[[0,"iter = ["],[-1,"0 "],[0,"] #['min"]],5813,5813,18,16]],"time":1423268743340}
{"patch":[[[[0,"iter = ["],[1,"'0"],[0,"] #['min"]],5813,5813,16,18]],"time":1423268742589}
{"patch":[[[[0,"er = ['0"],[1,"'"],[0,"] #['min"]],5815,5815,16,17]],"time":1423268741840}
{"patch":[[[[0,"r = ['0'"],[-1,"]"],[0," #['minm"]],5816,5816,17,16]],"time":1423268715358}
{"patch":[[[[0,"er = ['0"],[-1,"'"],[0," #['minm"]],5815,5815,17,16]],"time":1423268714609}
{"patch":[[[[0,"iter = ["],[-1,"'"],[0,"0 #['min"]],5813,5813,17,16]],"time":1423268713783}
{"patch":[[[[0,"miter = "],[-1,"["],[0,"0 #['min"]],5812,5812,17,16]],"time":1423268713032}
{"patch":[[[[0,"iter = 0"],[-1," "],[0,"#['minmo"]],5813,5813,17,16]],"time":1423268689407}
{"patch":[[[[0,"miter = "],[-1,"0"],[0,"#['minmo"]],5812,5812,17,16]],"time":1423268688655}
{"patch":[[[[0,"miter = "],[1,"["],[0,"#['minmo"]],5812,5812,16,17]],"time":1423268686640}
{"patch":[[[[0,"miter = "],[-1,"["],[0,"#['minmo"]],5812,5812,17,16]],"time":1423268685816}
{"patch":[[[[0,"miter = "],[-1,"#"],[0,"['minmod"]],5812,5812,17,16]],"time":1423268683806}
{"patch":[[[[0,"final = "],[-1,"3"],[1,"2"],[0,".000000\n"]],3148,3148,17,17]],"time":1423268533183}
{"patch":[[[[0,"0] = 200"],[1,"0"],[0,"      # "]],1733,1733,16,17]],"time":1423268508733}
{"patch":[[[[0,"ls[0] = "],[-1,"200"],[0,"0      #"]],1730,1730,19,16]],"time":1423268507981}
{"patch":[[[[0,"ls[0] = "],[1,"1"],[0,"0      #"]],1730,1730,16,17]],"time":1423268507273}
{"patch":[[[[0,"ls[0] = "],[-1,"1"],[0,"0      #"]],1730,1730,17,16]],"time":1423268361332}
{"patch":[[[[0,"ls[0] = "],[1,"5"],[0,"0      #"]],1730,1730,16,17]],"time":1423268360598}
{"patch":[[[[0,"s[0] = 5"],[-1,"0"],[0,"      # "]],1731,1731,17,16]],"time":1423268273639}
{"patch":[[[[0,"ls[0] = "],[-1,"5"],[1,"200"],[0,"      # "]],1730,1730,17,19]],"time":1423268272822}